package com.bitOperate;

import org.junit.Test;

public class BitOperate {
    public static void main(String[] args) {
    }

    /**
     * 1、测试 >> ：符号位不动，在补码的基础上操作，正数高位补0，负数高位补1
     *             正数的意义是：>>1代表除2，>>2代表除4
     *            负数的意义是： 同正数，但结果是往数轴的左边取整 如-17 >> 3 = -2.1 ,-2.1向左取证得-3
     *       意义：都代表除，但是结果需要往数轴的左边取整
     *
     * 需要再补码上进行操作 正数由于源码、反码、补码一致，因此可以直接再源码上操作，而负数需要转换为补码
     */
    @Test
    public void text1(){
        //正数的>>

        // 17       0000 0000 0000 0000 0000 0000 0001 0001
        // 17 >> 3  0000 0000 0000 0000 0000 0000 0000 0010
        int i = 17 >> 3;
        System.out.println("17 >> 3 : " + i); // 2

        // 16       0000 0000 0000 0000 0000 0000 0001 0000
        // 16 >> 3  0000 0000 0000 0000 0000 0000 0000 0010  高位补0
        int i1 = 16 >> 3;
        System.out.println("16 >> 3 : " + i1); // 2

        //结论：对于正数来说>>1代表除2, 而>>3代表除8；因此16和17除8都等于2(余数不考虑)

        // 负数的>>
        // -17   源码    1000 0000 0000 0000 0000 0000 0001 0001
        // -17   反码    1111 1111 1111 1111 1111 1111 1110 1110
        // -17   补码    1111 1111 1111 1111 1111 1111 1110 1111

        // -17 >> 3 结果 1111 1111 1111 1111 1111 1111 1111 1101  在补码的基础上操作 负数高位补1

        //结果的反码     1111 1111 1111 1111 1111 1111 1111 1100  补码还原成反码 ：补码-1
        //结果的源码     1000 0000 0000 0000 0000 0000 0000 0011   = -3
        int i2 = -17 >> 3;
        System.out.println("-17 >> 3 : " + i2); // -3

        // -16   源码    1000 0000 0000 0000 0000 0000 0001 0000
        // -16   反码    1111 1111 1111 1111 1111 1111 1110 1111
        // -16   补码    1111 1111 1111 1111 1111 1111 1111 0000

        // -16 >> 3 结果 1111 1111 1111 1111 1111 1111 1111 1110  在补码的基础上操作 负数高位补1

        //结果的反码     1111 1111 1111 1111 1111 1111 1111 1101  补码还原成反码 ：补码-1
        //结果的源码     1000 0000 0000 0000 0000 0000 0000 0010   = -2
        int i3 = -16 >> 3;
        System.out.println("-16 >> 3 : " + i3); // -2

        //结论：对于负数来说>>1不代表除2，一切的操作都是在补码上进行，且高位补1
    }

    /**
     * 1、测试 <<
     *      意义：无论正负数，<<1，代表乘2，<<3代表乘8
     */
    @Test
    public void text2(){
        //正数的<<

        // 17       0000 0000 0000 0000 0000 0000 0001 0001
        // 17 << 3  0000 0000 0000 0000 0000 0000 1000 1000
        int i = 17 << 3;
        System.out.println("17 << 3 : " + i); // 136 = 17 * 8

        // 16       0000 0000 0000 0000 0000 0000 0001 0000
        // 16 << 3  0000 0000 0000 0000 0000 0000 1000 0000
        int i1 = 16 << 3;
        System.out.println("16 << 3 : " + i1); // 128 = 16 * 8

        //结论：对于正数来说<<1代表乘2, 而<<3代表乘8

        // 负数的>>
        // -17   源码    1000 0000 0000 0000 0000 0000 0001 0001
        // -17   反码    1111 1111 1111 1111 1111 1111 1110 1110
        // -17   补码    1111 1111 1111 1111 1111 1111 1110 1111

        // -17 << 3 结果 1111 1111 1111 1111 1111 1111 0111 1000  在补码的基础上操作 负数低位补0(低位都得补0，无论正负数)

        //结果的反码     1111 1111 1111 1111 1111 1111 0111 0111  补码还原成反码 ：补码-1
        //结果的源码     1000 0000 0000 0000 0000 0000 1000 1000   = -136
        int i2 = -17 << 3;
        System.out.println("-17 << 3 : " + i2); // -136

        // -16   源码    1000 0000 0000 0000 0000 0000 0001 0000
        // -16   反码    1111 1111 1111 1111 1111 1111 1110 1111
        // -16   补码    1111 1111 1111 1111 1111 1111 1111 0000

        // -16 << 3 结果 1111 1111 1111 1111 1111 1111 1000 0000  在补码的基础上操作 低位都得补0，无论正负数

        //结果的反码     1111 1111 1111 1111 1111 1111 0111 1111  补码还原成反码 ：补码-1
        //结果的源码     1000 0000 0000 0000 0000 0000 1000 0000   = -128
        int i3 = -16 << 3;
        System.out.println("-16 << 3 : " + i3); // -2

        //结论：对于正数来说<<1代表乘2, 而<<3代表乘8
    }

    /**
     * 测试 >>>
     *      在补码的基础上进行右移
     *      结果也不要用还原成源码(因为不管符号)
     *
     * 没有<<<这种操作
     */
    @Test
    public void test3(){
        // 测试正数 >>>
        // 17       0000 0000 0000 0000 0000 0000 0001 0001
        // 17 >>> 3 0000 0000 0000 0000 0000 0000 0000 0010
        int i1 = 17 >>> 3;
        System.out.println("17 >>> 3 : "+i1);   // 2

        // 16       0000 0000 0000 0000 0000 0000 0001 0000
        // 16 >>> 3 0000 0000 0000 0000 0000 0000 0000 0010
        int i2 = 16 >>> 3;
        System.out.println("16 >>> 3 : "+i2);   // 2

        // 结论 ：连符号为也移

        // 测试负数 >>>
        // -17 源码  1000 0000 0000 0000 0000 0000 0001 0001
        // -17 反码  1111 1111 1111 1111 1111 1111 1110 1110
        // -17 补码  1111 1111 1111 1111 1111 1111 1110 1111
        // -17>>>3   0001 1111 1111 1111 1111 1111 1111 1101    （不用还原成源码）
        int i3 = -17 >>> 3;
        System.out.println("-17 >>> 3 : "+i3);
        System.out.println(Integer.toBinaryString(i3)); //返回其补码得形式

        // -1  源码  1000 0000 0000 0000 0000 0000 0000 0001
        // -1  反码  1111 1111 1111 1111 1111 1111 1111 1110
        // -1  补码  1111 1111 1111 1111 1111 1111 1111 1111
        // -1 >>>3   0001 1111 1111 1111 1111 1111 1111 1111
        int i4 = -1 >>> 3;
        System.out.println("-1 >>> 3 : "+i4);

        // 结论：没什么意义
    }

    /**
     * 测试 &(与) |(或) ~(非)
     */
    @Test
    public void test4(){
        // 测试&（与）
        // 9 源码     0000 0000 0000 0000 0000 0000 0000 1001

        // -6 源码    1000 0000 0000 0000 0000 0000 0000 0110
        //    反码    1111 1111 1111 1111 1111 1111 1111 1001
        //    补码    1111 1111 1111 1111 1111 1111 1111 1010

        int i1 = 9;
        int i2 = -6;
        int r1 = i1 & i2;
        // 9 源码     0000 0000 0000 0000 0000 0000 0000 1001
        // -6  补码   1111 1111 1111 1111 1111 1111 1111 1010
        // 9 & -6     0000 0000 0000 0000 0000 0000 0000 1000
        System.out.println(" 9 & -6 = " + r1); // 8
        System.out.println(Integer.toBinaryString(r1));

        int r2 = i1 | i2;
        // 9 源码     0000 0000 0000 0000 0000 0000 0000 1001
        // -6  补码   1111 1111 1111 1111 1111 1111 1111 1010
        // 9 | -6     1111 1111 1111 1111 1111 1111 1111 1011   （补码负数 需要还原成源码）
        //      反码  1111 1111 1111 1111 1111 1111 1111 1010
        //      源码  1000 0000 0000 0000 0000 0000 0000 0101
        System.out.println(" 9 | -6 = " + r2); // -5

        int r3 = ~i1;
        // 9 源码     0000 0000 0000 0000 0000 0000 0000 1001
        // ~i1        1111 1111 1111 1111 1111 1111 1111 0110   补码负数 需要还原成源码
        // 反码       1111 1111 1111 1111 1111 1111 1111 0101
        // 反码       1000 0000 0000 0000 0000 0000 0000 1010
        System.out.println(" ~9 = "+r3); // -10
    }

    /**
     * 测试 异或^
     *  相同得0 不同得1
     */
    @Test
    public void test5(){
        // 9 源码     0000 0000 0000 0000 0000 0000 0000 1001

        // -6 源码    1000 0000 0000 0000 0000 0000 0000 0110
        //    反码    1111 1111 1111 1111 1111 1111 1111 1001
        //    补码    1111 1111 1111 1111 1111 1111 1111 1010
        int i1 = 9;
        int i2 = -6;
        int r1 = i1 ^ i2;
        //              0000 0000 0000 0000 0000 0000 0000 1001
        //                                                    ^
        //              1111 1111 1111 1111 1111 1111 1111 1010
        //          ==  1111 1111 1111 1111 1111 1111 1111 0011
        //反码          1111 1111 1111 1111 1111 1111 1111 0010
        //源码          1000 0000 0000 0000 0000 0000 0000 1101
        System.out.println("i1 ^ i2 = "+r1);
        System.out.println(Integer.toBinaryString(r1)); // 补码得形式 ：1111 1111 1111 1111 1111 1111 1111 0011
        //意义：可以用来算距离
    }
}
