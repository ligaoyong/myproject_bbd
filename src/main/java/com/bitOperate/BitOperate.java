package com.bitOperate;

import org.junit.Test;

public class BitOperate {
    public static void main(String[] args) {
    }

    /**
     * 1、测试 >> ：符号位不动，在补码的基础上操作，正数高位补0，负数高位补1
     *             正数的意义是：>>1代表除2，>>2代表除4
     *            负数的意义是： 同正数，但结果是往数轴的左边取整 如-17 >> 3 = -2.1 ,-2.1向左取证得-3
     *       意义：都代表除，但是结果需要往数轴的左边取整
     *
     * 需要再补码上进行操作 正数由于源码、反码、补码一致，因此可以直接再源码上操作，而负数需要转换为补码
     */
    @Test
    public void text1(){
        //正数的>>

        // 17       0000 0000 0000 0000 0000 0000 0001 0001
        // 17 >> 3  0000 0000 0000 0000 0000 0000 0000 0010
        int i = 17 >> 3;
        System.out.println("17 >> 3 : " + i); // 2

        // 16       0000 0000 0000 0000 0000 0000 0001 0000
        // 16 >> 3  0000 0000 0000 0000 0000 0000 0000 0010  高位补0
        int i1 = 16 >> 3;
        System.out.println("16 >> 3 : " + i1); // 2

        //结论：对于正数来说>>1代表除2, 而>>3代表除8；因此16和17除8都等于2(余数不考虑)

        // 负数的>>
        // -17   源码    1000 0000 0000 0000 0000 0000 0001 0001
        // -17   反码    1111 1111 1111 1111 1111 1111 1110 1110
        // -17   补码    1111 1111 1111 1111 1111 1111 1110 1111

        // -17 >> 3 结果 1111 1111 1111 1111 1111 1111 1111 1101  在补码的基础上操作 负数高位补1

        //结果的反码     1111 1111 1111 1111 1111 1111 1111 1100  补码还原成反码 ：补码-1
        //结果的源码     1000 0000 0000 0000 0000 0000 0000 0011   = -3
        int i2 = -17 >> 3;
        System.out.println("-17 >> 3 : " + i2); // -3

        // -16   源码    1000 0000 0000 0000 0000 0000 0001 0000
        // -16   反码    1111 1111 1111 1111 1111 1111 1110 1111
        // -16   补码    1111 1111 1111 1111 1111 1111 1111 0000

        // -16 >> 3 结果 1111 1111 1111 1111 1111 1111 1111 1110  在补码的基础上操作 负数高位补1

        //结果的反码     1111 1111 1111 1111 1111 1111 1111 1101  补码还原成反码 ：补码-1
        //结果的源码     1000 0000 0000 0000 0000 0000 0000 0010   = -2
        int i3 = -16 >> 3;
        System.out.println("-16 >> 3 : " + i3); // -2

        //结论：对于负数来说>>1不代表除2，一切的操作都是在补码上进行，且高位补1
    }

    /**
     * 1、测试 <<
     *      意义：无论正负数，<<1，代表乘2，<<3代表乘8
     */
    @Test
    public void text2(){
        //正数的<<

        // 17       0000 0000 0000 0000 0000 0000 0001 0001
        // 17 << 3  0000 0000 0000 0000 0000 0000 1000 1000
        int i = 17 << 3;
        System.out.println("17 << 3 : " + i); // 136 = 17 * 8

        // 16       0000 0000 0000 0000 0000 0000 0001 0000
        // 16 << 3  0000 0000 0000 0000 0000 0000 1000 0000
        int i1 = 16 << 3;
        System.out.println("16 << 3 : " + i1); // 128 = 16 * 8

        //结论：对于正数来说<<1代表乘2, 而<<3代表乘8

        // 负数的>>
        // -17   源码    1000 0000 0000 0000 0000 0000 0001 0001
        // -17   反码    1111 1111 1111 1111 1111 1111 1110 1110
        // -17   补码    1111 1111 1111 1111 1111 1111 1110 1111

        // -17 << 3 结果 1111 1111 1111 1111 1111 1111 0111 1000  在补码的基础上操作 负数低位补0(低位都得补0，无论正负数)

        //结果的反码     1111 1111 1111 1111 1111 1111 0111 0111  补码还原成反码 ：补码-1
        //结果的源码     1000 0000 0000 0000 0000 0000 1000 1000   = -136
        int i2 = -17 << 3;
        System.out.println("-17 << 3 : " + i2); // -136

        // -16   源码    1000 0000 0000 0000 0000 0000 0001 0000
        // -16   反码    1111 1111 1111 1111 1111 1111 1110 1111
        // -16   补码    1111 1111 1111 1111 1111 1111 1111 0000

        // -16 << 3 结果 1111 1111 1111 1111 1111 1111 1000 0000  在补码的基础上操作 低位都得补0，无论正负数

        //结果的反码     1111 1111 1111 1111 1111 1111 0111 1111  补码还原成反码 ：补码-1
        //结果的源码     1000 0000 0000 0000 0000 0000 1000 0000   = -128
        int i3 = -16 << 3;
        System.out.println("-16 << 3 : " + i3); // -2

        //结论：对于正数来说<<1代表乘2, 而<<3代表乘8
    }
}
